= Lab Setup and Prerequisites

== Prerequisites

Before starting this lab, ensure you have the following:

=== Required Tools
* **GitHub Account**: You'll need access to fork repositories and collaborate
* **Git CLI**: Installed and configured on your local machine
* **OpenShift CLI (oc)**: Download from https://mirror.openshift.com/pub/openshift-v4/clients/ocp/[OpenShift client downloads,window=_blank]
* **HashiCorp Vault CLI**: Download from https://developer.hashicorp.com/vault/install[Vault installation guide,window=_blank]
* **Terminal/Command Line**: Bash shell with basic utilities (openssl, curl)
* **Ansible Vault**: Part of Ansible toolkit for secret management
* **Web Browser**: For accessing OpenShift console, MaaS portal, and documentation

=== Required Skills
* **Basic Git Knowledge**: Cloning repositories, basic version control concepts
* **Command Line Basics**: Navigating directories, running commands
* **Container Concepts**: Understanding of containers and Kubernetes/OpenShift (helpful but not required)

=== Provided by Instructors
* **OpenShift Cluster Access**: GPU-enabled cluster with admin credentials
* **Red Hat MaaS Access**: Model-as-a-Service credentials for LLaMA models
* **Workshop Materials**: All necessary configuration files and scripts
* **Environment Variables**: Cluster-specific configuration values
* **Support**: Technical assistance throughout the lab

== Getting Started

Before diving into the agentic AI lab, we need to set up our development environment. This involves two key steps:

1. **Setting up GitOps**: Configure automated deployment pipelines that manage our infrastructure and applications
2. **Configuring Secret Management**: Set up secure handling of API keys and credentials using HashiCorp Vault

**Why this matters**: This approach keeps sensitive information (like API keys) separate from our code, following security best practices while enabling automated deployments.

[IMPORTANT]
====
**For this lab**: We'll use the automated https://github.com/redhat-ai-services/etx-agentic-ai/tree/main/infra/bootstrap[bootstrap scripts,window=_blank] to handle setup quickly so we can focus on building AI agents.
====

**For later exploration** (after the lab):

* **Manual setup**: The step-by-step instructions below show how each component works - perfect for understanding GitOps and secret management in detail



== Team Setup

. **You'll be working in teams of 2 people per cluster**
+
[NOTE]
====
**Why teams of two?**

* **Resource optimization**: GPU-enabled OpenShift clusters are expensive - sharing clusters allows us to provide everyone with powerful hardware
* **Better learning**: https://openpracticelibrary.com/practice/pair-programming/[Pair programming,window=_blank] increases knowledge sharing and helps troubleshoot issues faster
* **Real-world practice**: Most production AI/ML teams work collaboratively on shared infrastructure and have a mixture of roles and expertise

This setup mirrors how teams work with shared cloud resources in enterprise environments.
====

. **Receive your cluster credentials** üîê
+
Your instructor will provide OpenShift login credentials for your team's shared cluster.

. **Set up your shared repository** (choose one team member to do this):
.. https://github.com/redhat-ai-services/etx-agentic-ai[Fork the etx-agentic-ai repository,window=_blank] to your personal GitHub account
+
.GitHub Repo Fork
image::github-fork.png[GitHub Repo Fork, 400]
.. Add your teammate as a collaborator with write access
+
.GitHub Repo Collaborators  
image::github-collaborators.png[GitHub Repo Collaborators, 400]

. **Both team members: Clone the forked repository locally**
+
[source,bash,options="wrap",role="execute"]
----
git clone git@github.com:your-gh-user/etx-agentic-ai.git
cd etx-agentic-ai
----
+
.GitHub Repo Clone
image::github-clone.png[GitHub Repo Clone, 400]
+
[TIP]
====
Replace `your-gh-user` with the actual GitHub username of whoever forked the repository.
====

. **Verify your setup** ‚úÖ
+
You should now have:
+
* Access to your team's OpenShift cluster
* A shared fork of the repository with both teammates as collaborators  
* Local copies of the code on both laptops

== Cluster Environment

Your team has access to a fully-featured OpenShift cluster designed for AI workloads. This cluster mimics many customer production environments. Here's how the platform is architected:

=== Bootstrap Components
These foundational components are deployed first to establish the platform's operational baseline:

* **Red Hat OpenShift**: Enterprise Kubernetes platform providing container orchestration
* **Advanced Cluster Management (ACM)**: Multi-cluster governance and GitOps orchestration
* **ArgoCD**: Declarative, Git-driven application deployments
* **HashiCorp Vault**: Secure credential storage and automated secret injection

=== Security & Governance
Built on the bootstrap foundation, these components enforce enterprise policies:

[IMPORTANT]
.Policy as Code
====
**Everything is managed through automated policy enforcement:**

* **Zero Configuration Drift**: What's in Git is exactly what runs in production
* **Automated Compliance**: Policies are enforced automatically, not through manual reviews
* **Scalable Governance**: Manage hundreds of clusters with the same effort as one
* **Declarative Security**: Security policies are versioned, tested, and automatically applied

**How this differs from standard GitOps**: While traditional GitOps deploys applications, Policy as Code deploys and enforces the _rules_ that govern how applications can behave, what resources they can access, and how they must be configured. The policies themselves are GitOps-managed, creating a "governance layer" above your applications.

**Green from GO** ‚úÖ: We start compliant from day one. Rather than building systems and retrofitting security and compliance later, our development environment mirrors production with all policies active from the beginning. This means teams learn to work within enterprise guardrails naturally.

This approach ensures software quality, security, and consistency at enterprise scale.
====

.Policy as Code using GitOps and ACM
image::policy-as-code.png[Policy as Code, 600]

* **Policy Enforcement**: ACM automatically applies and monitors compliance across all workloads in all clusters (particularly useful for large-scale multi-cluster environments)
* **Observability Stack**: Comprehensive monitoring, logging, and tracing for security insights
* **GPU Resource Management**: Node Feature Discovery (NFD) for specialized compute allocation

=== Developer Platform Services
Self-service capabilities that enable development teams:

* **CI/CD Pipelines**: Tekton for automated container builds, testing, and deployments
* **Source Control Integration**: Git-based workflows with automated quality gates
* **Container Registry**: Secure image storage with vulnerability scanning and promotion workflows

=== Tenant & Workload Services
Multi-tenant capabilities providing isolated, secure environments:

* **Namespace Management**: Multi-tenant isolation with RBAC and resource quotas
* **Development Workbenches**: Self-service Jupyter environments for data science teams
* **Service Mesh**: Secure service-to-service communication and traffic management

=== AI/ML Platform Services
Specialized services for AI/ML workloads and agentic applications:

* **Red Hat OpenShift AI (RHOAI)**: Managed AI/ML platform with GPU acceleration
* **Model Serving Infrastructure**: Scalable inference endpoints with model lifecycle management
* **Agentic AI Runtime**: Environment for deploying AI agents with external service integrations

[TIP]
====
**LLaMA Stack Integration**: Our agentic AI workloads leverage https://github.com/meta-llama/llama-stack[LLaMA Stack,window=_blank], a composable framework that provides standardized APIs for model inference, safety guardrails, and tool integration. This allows our AI agents to seamlessly interact with large language models while maintaining consistent interfaces for memory management, tool calling, and safety controls across different model providers.
====

**The Benefits:**

* **ZERO configuration drift** - what's in git is real
* **Integrates into the Governance Dashboard in ACM for SRE**
* **We start as we mean to go on** - we are Green from GO so that our dev environment looks like prod only smaller
* **All our clusters and environments are Kubernetes Native once bootstrapped**

== Required Applications

As a Team, you need to do each of these Prerequisites.

. Choose a client to bootstrap from. It could be:
*** Your https://www.dell.com/en-au/shop/dell-laptops/xps-16-laptop/spd/xps-16-9640-laptop[Laptop,window=_blank] or a https://docs.fedoraproject.org/en-US/fedora-silverblue/toolbox[Toolbx,window=_blank] or a https://docs.fedoraproject.org/en-US/docs/[Fedora like jumphost,window=_blank] or a https://docs.redhat.com/en/documentation/red_hat_openshift_ai_cloud_service/1/html/working_on_data_science_projects/using-project-workbenches_projects#creating-a-project-workbench_projects[Workbench Terminal,window=_blank] that can access your cluster and the internet
** Your bootstrap client must have a https://packages.fedoraproject.org/pkgs/bash/bash/[bash] shell with https://packages.fedoraproject.org/pkgs/openssl/openssl/[openssl,window=_blank], https://docs.ansible.com/ansible/2.9/cli/ansible-vault.html#ansible-vault[ansible-vault,window=_blank] installed
** Download and https://developer.hashicorp.com/vault/install[Install the Hashi Vault Client binary,window=_blank]
** Login to your OpenShift cluster using the https://mirror.openshift.com/pub/openshift-v4/clients/ocp/[OpenShift client,window=_blank] as the cluster-admin user

. Setup env vars
+
[source,bash,options="wrap",role="execute"]
----
export ADMIN_PASSWORD=password # replace with yours
export CLUSTER_NAME=cluster-4xglk.4xglk # replace with yours
export BASE_DOMAIN=sandbox2518.opentlc.com # replace with yours
----
+
[source,bash,options="wrap",role="execute"]
----
oc login --server=https://api.${CLUSTER_NAME}.${BASE_DOMAIN}:6443 -u admin -p ${ADMIN_PASSWORD}
----

. Done ‚úÖ

=== MaaS credentials

Gather your Model as a Service Credentials.

. Login to https://maas.apps.prod.rhoai.rh-aiservices-bu.com[Models-as-a-service using your RedHat credentials,window=_blank].
. Click on the __See your Applications & their credentials__ button.
. Create 3 Applications for these three models
** **Llama-3.2-3B**
** **Llama-4-Scout-17B-16E-W4A16**
** **Nomic-Embed-Text-v1.5**
+
e.g. for example __llama-4-scout-17b-16e-w4a16__
+
.MaaS LLama4 Scout
image::maas-llama-4-scout-17b-16e-w4a16.png[MaaS LLama4 Scout, 400]

. Setup env vars
+
[source,bash,options="wrap",role="execute"]
----
export MODEL_LLAMA3_API_KEY=e3...
export MODEL_LLAMA3_ENDPOINT_URL=https://llama-3-2-3b-maas-apicast-production.apps.prod.rhoai.rh-aiservices-bu.com:443
export MODEL_LLAMA3_NAME=llama-3-2-3b

export MODEL_LLAMA4_API_KEY=ce...
export MODEL_LLAMA4_ENDPOINT_URL=https://llama-4-scout-17b-16e-w4a16-maas-apicast-production.apps.prod.rhoai.rh-aiservices-bu.com:443
export MODEL_LLAMA4_NAME=llama-4-scout-17b-16e-w4a16

export MODEL_EMBED_API_KEY=95...
export MODEL_EMBED_URL=https://nomic-embed-text-v1-5-maas-apicast-production.apps.prod.rhoai.rh-aiservices-bu.com:443
export MODEL_EMBED_NAME=/mnt/models
----

. Done ‚úÖ

=== Vault Setup for GitOps

We need to setup vault for your environment.

. Initialize the vault. Make sure you record the **UNSEAL_KEY** and **ROOT_TOKEN** somewhere safe and export them as env vars.
+
[source,bash,options="wrap",role="execute"]
----
oc -n vault exec -ti vault-0 -- vault operator init -key-threshold=1 -key-shares=1 -tls-skip-verify
----
+
[source,bash,options="wrap",role="execute"]
----
export UNSEAL_KEY=EGbx...
export ROOT_TOKEN=hvs.wnz...
----

After running the vault initialization command, you'll see output containing the unseal key and root token. Copy these values and export them as environment variables as shown.

image::vault-init.png[Vault initialization output showing unseal key and root token]

. Unseal the Vault.
+
[source,bash,options="wrap",role="execute"]
----
oc -n vault exec -ti vault-0 -- vault operator unseal -tls-skip-verify $UNSEAL_KEY
----

. Setup secrets for gitops.
+
TIP: (Optional Reading) You can see more details of this sort of setup https://eformat.github.io/rainforest-docs/#/2-platform-work/3-secrets[here,window=_blank] if you need more background.

. Setup env vars
+
[source,bash,options="wrap",role="execute"]
----
export VAULT_ROUTE=vault-vault.apps.${CLUSTER_NAME}.${BASE_DOMAIN}
export VAULT_ADDR=https://${VAULT_ROUTE}
export VAULT_SKIP_VERIFY=true
----

. Login to Vault.
+
[source,bash,options="wrap",role="execute"]
----
vault login token=${ROOT_TOKEN}
----

You should see the following output:
+
.Vault Login
image::vault-login.png[Vault Login, 400]

. Setup env vars
+
[source,bash,options="wrap",role="execute"]
----
export APP_NAME=vault
export PROJECT_NAME=openshift-policy
export CLUSTER_DOMAIN=apps.${CLUSTER_NAME}.${BASE_DOMAIN}
----

. Create the Vault Auth using Kubernetes auth
+
[source,bash,options="wrap",role="execute"]
----
vault auth enable -path=${CLUSTER_DOMAIN}-${PROJECT_NAME} kubernetes
export MOUNT_ACCESSOR=$(vault auth list -format=json | jq -r ".\"$CLUSTER_DOMAIN-$PROJECT_NAME/\".accessor")
----

. Create an ACL Policy - ArgoCD will only be allowed to __READ__ secret values for hydration into the cluster
+
[source,bash,options="wrap",role="execute"]
----
vault policy write $CLUSTER_DOMAIN-$PROJECT_NAME-kv-read -<< EOF
path "kv/data/*" {
capabilities=["read","list"]
}
EOF
----

. Enable kv2 to store our secrets
+
[source,bash,options="wrap",role="execute"]
----
vault secrets enable -path=kv/ -version=2 kv
----

. Bind the ACL to Auth policy
+
[source,bash,options="wrap",role="execute"]
----
vault write auth/$CLUSTER_DOMAIN-$PROJECT_NAME/role/$APP_NAME \
bound_service_account_names=$APP_NAME \
bound_service_account_namespaces=$PROJECT_NAME \
policies=$CLUSTER_DOMAIN-$PROJECT_NAME-kv-read \
period=120s
----

. Grab the cluster CA certificate on the API
+
[source,bash,options="wrap",role="execute"]
----
CA_CRT=$(openssl s_client -showcerts -connect api.${CLUSTER_NAME}.${BASE_DOMAIN}:6443 2>&1 | awk '/BEGIN CERTIFICATE/,/END CERTIFICATE/ {print $0}')
----

. Add the initial token and CA cert to the Vault Auth Config.
+
[source,bash,options="wrap",role="execute"]
----
vault write auth/${CLUSTER_DOMAIN}-${PROJECT_NAME}/config \
kubernetes_host="$(oc whoami --show-server)" \
kubernetes_ca_cert="$CA_CRT"
----

. Done ‚úÖ

==== Create a CronJob

[TIP]
====
In case the vault pod, or the node it runs on, reboots, it is always handy to auto unseal the vault.

[source,bash,options="wrap",role="execute"]
----
export UNSEAL_KEY=EGbx...
----

[source,bash,options="wrap",role="execute"]
----
cat infra/bootstrap/vault-unseal-cronjob.yaml | envsubst | oc apply -f-
----

image::vault-cronjob.png[Vault Cronjob Created, 600]

Done ‚úÖ
====

=== Tavily search token

Gather your Tavily web search API Key.

. Setup a https://app.tavily.com[Tavily,window=_blank] api key for web search. Login using a github account of one of your team members.
+
.Tavily API Key
image::tavily-apikey.png[Create Tavily API Key, 600]

. Done ‚úÖ

=== GitHub Token

Create a fine-grained GitHub Personal Access (PAT) Token.

. Login to GitHub in a browser, then click on your user icon > **Settings**

. Select **Developer Settings** > **Personal Access Tokens** > **Fine-grained personal access tokens**

. Select Button **Generate a new token** - give it a token name e.g. __etx-ai__

. Set **Repository access** > **Use Only select repositories**
+
.GitHub Repo Access
image::github-access.png[GitHub Repo Access, 400]

. Give it the following permissions:
+
**All repositories**: allow access to your repositories including read-only public repos.
+
**Commit statuses**: Read-Only
+
**Content**: Read-Only
+
**Issues**: Read and Write
+
**Metadata**: Read-Only (this gets added automatically)
+
**Pull requests**: Read-Only
+
.GitHub Repo Perms
image::github-repo-perms.png[GitHub Repo Perms, 400]

. Generate the token.
+
.GitHub Repo Token
image::github-pat.png[GitHub Repo Token, 400]

. Done ‚úÖ

=== GitHub Webhook

Create a webhook that fires from your GitHub repo fork to ArgoCD on the OpenShift Cluster. This ensures the applications are synced whenever you push a change into git (rather than wait the 3min default sync time).

. Login to GitHub in a browser, go to your **etx-agentic-ai** fork > **Settings**

. Select **Webhooks**

. Select **Add Webhook**. Add the following details
+
**Payload URL:** https://global-policy-server-openshift-policy.apps.${CLUSTER_NAME}.${BASE_DOMAIN}/api/webhook
+
**Content Type:** application/json
+
**SSL Verification:** Enable SSL Verification
+
**Which events:** Send me everything

. Click **Add Webhook**
+
.GitHub Webhook
image::github-webhook.png[GitHub Webhook, 400]

. Done ‚úÖ

=== The Secrets File

[IMPORTANT]
.Why Do This
====
We need to be able to hydrate the vault from a single source of truth. It makes secret management very efficient. In the case if a disaster, we need to recover the vault environment quickly. We can check this file into git as an AES256 encoded file (until quantum cracks it ‚ùà).
====

The secrets file is just a bash shell script that uses the vault cli.

. Copy the example secrets file provided
+
[source,bash,options="wrap",role="execute"]
----
cp infra/secrets/vault-sno-example infra/secrets/vault-sno
----
+
TIP: If the secrets file was encrypted we could unencrypt is as follows
+
[source,bash,options="wrap",role="execute"]
----
ansible-vault decrypt infra/secrets/vault-sno
----

. Add the gathered api tokens as env vars to the secrets file and save it.
+
.Add API Tokens
image::add-apikeys-secrets.png[Add API Tokens, 300]

. Setup env vars
+
[source,bash,options="wrap",role="execute"]
----
export VAULT_ROUTE=vault-vault.apps.${CLUSTER_NAME}.${BASE_DOMAIN}
export VAULT_ADDR=https://${VAULT_ROUTE}
export VAULT_SKIP_VERIFY=true
----

. Login to Vault.
+
[source,bash,options="wrap",role="execute"]
----
vault login token=${ROOT_TOKEN}
----

. Hydrate the vault by running the secrets file as a script. When prompted to enter the root token, use the $ROOT_TOKEN you exported earlier.
+
[source,bash,options="wrap",role="execute"]
----
sh infra/secrets/vault-sno
----

. Encrypt the secrets file and check it back into your git fork. Generate a large secret key to use to encrypt the file and keep it safe.
+
TIP: you can put the key in vault üîë
+
[source,bash,options="wrap",role="execute"]
----
openssl rand -hex 32
----

. Ansible vault encrypt will prompt you for the Key twice
+
[source,bash,options="wrap",role="execute"]
----
ansible-vault encrypt infra/secrets/vault-sno
----

. Add to git
+
[source,bash,options="wrap",role="execute"]
----
# Its not real unless its in git
git add infra/secrets/vault-sno; git commit -m "hydrated vault with apikeys"; git push
----
+
[TIP]
.Optional
====
You can add a pre-commit git hook client side so that you do not check in an unencrypted AES256 secrets file. Run this after cloning forked repo to configure git hooks:

[source,bash,options="wrap",role="execute"]
----
chmod 755 infra/bootstrap/pre-commit
cd .git/hooks
ln -s ../../infra/bootstrap/pre-commit pre-commit
----
====

. Lastly, create the secret used by ArgoCD to connect to Vault in our OpenShift cluster. Since the OpenShift TokenAPI is used, we only really reference the service account details.
+
[source,yaml,options="wrap",role="execute"]
----
cat <<EOF | oc apply -f-
kind: Secret
apiVersion: v1
metadata:
  name: team-avp-credentials
  namespace: openshift-policy
stringData:
  AVP_AUTH_TYPE: "k8s"
  AVP_K8S_MOUNT_PATH: "auth/${CLUSTER_DOMAIN}-${PROJECT_NAME}"
  AVP_K8S_ROLE: "vault"
  AVP_TYPE: "vault"
  VAULT_ADDR: "https://vault.vault.svc:8200"
  VAULT_SKIP_VERIFY: "true"
type: Opaque
EOF
----

Your _cluster_ ArgoCD will now be able to read secrets from Vault and should be in a healthy state.

image::vault-health.png[Vault Health, 600]

. You can also login to Vault using the Vault UI and $ROOT_TOKEN from the OpenShift web console to check out the configuration
+
.Login to Vault
image::vault-console.png[Login to Vault, 400]

. Done ‚úÖ

=== üí• Expert Mode üí•

[IMPORTANT]
.Experts Only ‚õ∑Ô∏è
====
Only run this script if you are familiar with the Hashi Vault setup we just ran through and you skipped to here. Run the all-in-one vault setup script.

[source,bash,options="wrap",role="execute"]
----
export CLUSTER_NAME=cluster-4xglk.4xglk
export BASE_DOMAIN=sandbox2518.opentlc.com
export AWS_PROFILE=etx-ai
export ADMIN_PASSWORD=password
export ANSIBLE_VAULT_SECRET=94bbffb36de4285abcf95b5d650e0790c13939bc0e2f5214aaf58196456b8989

./infra/bootstrap/vault-setup.sh
----

Done ‚úÖ
====

== Complete the Bootstrap

. Setup env vars
+
[source,bash,options="wrap",role="execute"]
----
export CLUSTER_NAME=cluster-4xglk.4xglk # replace with yours
export BASE_DOMAIN=sandbox2518.opentlc.com # replace with yours
----

. Create https://docs.redhat.com/en/documentation/openshift_container_platform/4.19/html/console_apis/consolelink-console-openshift-io-v1[OpenShift ConsoleLinks,window=_blank] (some of which may already exist)

image::add-console-links.png[Console Links, 600]
+
[source,bash,options="wrap",role="execute"]
----
cat infra/bootstrap/console-links.yaml | envsubst | oc apply -f-
----

. Bootstrap https://argo-cd.readthedocs.io/en/latest/operator-manual/cluster-bootstrapping/#app-of-apps-pattern[App-of-Apps,window=_blank]
+
[source,bash,options="wrap",role="execute"]
----
# We need to update our ArgoCD Apps to point to your team fork
export YOUR_GITHUB_USER=your-gh-user  # the Team member who forked the GitHub Repo
cd etx-agentic-ai   # Navigate to root directory of code base if not already there
----

. Replace the `redhat-ai-services` throughout the file with your GitHub username.
+
[source,bash,options="wrap",role="execute"]
----
sed -i "s/redhat-ai-services/${YOUR_GITHUB_USER}/g" infra/app-of-apps/etx-app-of-apps.yaml
----

. Update the `redhat-ai-services` to your GitHub username in the `etx-app-of-apps.yaml` file.
+
[source,bash,options="wrap",role="execute"]
----
for x in $(ls infra/app-of-apps/sno); do
    sed -i "s/redhat-ai-services/${YOUR_GITHUB_USER}/g" infra/app-of-apps/sno/$x
done
----

. Now we can save, commit, and push the changes to your GitHub fork.
+
[source,bash,options="wrap",role="execute"]
----
# Its not real unless its in git
git add .; git commit -m "using my github fork"; git push
----

. Finally, we can bootstrap the apps into our cluster.
+
[source,bash,options="wrap",role="execute"]
----
# Bootstrap all our apps
oc apply -f infra/app-of-apps/etx-app-of-apps.yaml
----
+
This will install the tenant pipeline app and observability stack into our cluster. All the other GenAI apps are undeployed for now. You can check this in your _app-of-apps/cluster-name_ github fork folder.
+
image::bootstrap-initial.png[bootstrap-initial, 400]

. Check Install
+
[source,bash,options="wrap",role="execute"]
----
export CLUSTER_NAME=cluster-4xglk.4xglk
export BASE_DOMAIN=sandbox2518.opentlc.com
----
+
[source,bash,options="wrap",role="execute"]
----
./infra/bootstrap/check-install.sh
----

image::bootstrap-begin.png[bootstrap-begin, 400]

. Done ‚úÖ

. You will need to wait for the individual apps to be installed. This may take a few minutes. After a few minutes, you should see the following output to show that the apps have been installed.

image::bootstrap-complete.png[bootstrap-complete, 400]

Also, notice that the `tenant-ai-agent-local-cluster` app is constantly in a progressing state. This is something we will address later in this course.

== Workbench

. Create a Workbench environment for development

. Done ‚úÖ

== Technical Knowledge

Ideally https://www.redhat.com/tracks/_pfcdn/assets/10330/contents/344388/925d2cb5-39c2-49dc-9ed2-3f4aeeb52a85.pdf[your team is a cross-functional one (Optional: Read Chapter.1 - Introduction),window=_blank] with:

* Good understanding of OpenShift/Kubernetes concepts
* Basic familiarity with Python programming
* Good knowledge of https://www.redhat.com/en/topics/containers[containerization,window=_blank] concepts
* Basic understanding of CI/CD pipelines
* Good grasp of https://openpracticelibrary.com/practice/gitops[GitOps,window=_blank] and https://openpracticelibrary.com/practice/everything-as-code[Everything as Code practices,window=_blank]

xref:module-01.adoc[‚òï Buckle Up], Here we go ...

// lightbox - for images - FIXME need to make the include::partial$lightbox.hbs WORK
++++
<div id="myModal" class="modal">
    <span class="close cursor" onclick="closeModal()">&times;</span>
    <div class="modal-content" onclick="closeModal()">
        <!--suppress HtmlRequiredAltAttribute as this will be set when selecting the image via JavaScript,
        RequiredAttributes as src will be set by when selecting the image via JavaScript -->
        <img id="imageinmodal">
    </div>
</div>
<script>
    function openModal() {
        document.getElementById("myModal").style.display = "block";
        // use overflowY = hidden to prevent the body from scrolling when modal is visible
        // doesn't work with overscroll-behavior, as this would work only when the modal has a scrollbar
        document.getElementsByTagName("body")[0].style.overflowY = "hidden";
    }

    function closeModal() {
        document.getElementById("myModal").style.display = "none";
        document.getElementsByTagName("body")[0].style.overflowY = "auto";
    }

    document.querySelectorAll('.imageblock img').forEach(element => {
        if (element.closest('a') === null) {
            element.className += " lightbox";
            element.addEventListener('click', evt => {
                document.getElementById("imageinmodal").setAttribute("src", evt.currentTarget.getAttribute("src"))
                document.getElementById("imageinmodal").setAttribute("alt", evt.currentTarget.getAttribute("alt"))
                openModal();
            })
        }
    });
</script>
<style>
    /* The Modal (background) */
    .modal {
        display: none;
        position: fixed;
        z-index: 10;
        padding-top: 5vh;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        backdrop-filter: blur(3px);
        background-color: rgba(30, 30, 30, 0.8);
    }
    img.lightbox {
        cursor: pointer;
    }
    /* Modal Content */
    .modal-content {
        position: relative;
        margin: auto;
        padding: 0;
        width: 90%;
        max-height: 90vh;
        cursor: pointer;
    }

    .modal-content img {
        width: auto;
        height: auto;
        max-width: 90vw;
        max-height: 90vh;
        min-width: 90vw;
        min-height: 90vh;
        display: block;
        margin-right: auto;
        margin-left: auto;
        object-fit: contain;
    }

    /* The Close Button */
    .close {
        color: white;
        position: absolute;
        top: 10px;
        right: 25px;
        font-size: 35px;
        font-weight: bold;
    }

    .close:hover,
    .close:focus {
        color: #999;
        text-decoration: none;
        cursor: pointer;
    }
</style>
++++
